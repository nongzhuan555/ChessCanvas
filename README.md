# 关于ChessCanvas

### 简介

ChessCanvas是一个**轻量级、非普适（只针对中国象棋场景）的Canvas（2D）**操作库，旨在提供一种**开箱即用**的基于Web语言的中国象棋应用渲染方案。

### 背景

......

### 设计思路

- ***三层canvas结构***

​		*由下到上一共三层canvas*，分别是：

		1.  棋盘层canvas，这层canvas只负责渲染棋盘，理想情况下只初始化渲染一次
		2.  棋子层canvas，这层canvas统一绘制所有棋子，且支持差量重绘，只对正在动画的棋子进行局部清除、重绘
		3.  事件层canvas，这层canvas负责统一事件管理，处理所有由点击触发的象棋事件，如选中棋子等等

​		多层canvas设计的**好处**在于：

		1.  支持*差量渲染*，只对应该重新绘制的视图元素进行重绘，比如一局象棋游戏中的棋盘应该自初始化绘制成功后始终不变，再比如象棋规则中同一时间要么没有棋子移动，要么只能有一个棋子移动，因此完全没有必要清空整个画布再重绘压根没有移动过的棋子，这是多余的绘制开销。在ChessCanvas中，通过将棋盘层放在最底层，棋子绘制在第二层，使得棋盘和棋子的渲染各不相干。棋子移动时的差量渲染和分层设计看起来关系不大，其原理为在每一帧动画中，仅清空棋子当前位置的画布（理论上来说，清空画布区域越小，性能越好，尽管并没有太明显），然后绘制棋子的下一帧。但能够如此简单的做到棋子的差量渲染要感谢分层canvas的设计，试想，如果棋盘和棋子在同一个canvas中，对棋子的擦除必然也会擦除其下方的棋盘，我们就需要花额外的精力来想办法补上棋盘！
		1.  遵循*单一职责*原则：棋盘层只负责渲染棋盘并触发棋盘创建的生命周期；棋子层只初始化绘制棋子、处理棋子移动以及维护棋盘状态（体现为一个和棋盘每个落点同构的二维数组）；事件层是一个和棋盘同样大小并完美覆盖的透明canvas，它统一处理用户点击，分发象棋相关事件。

- ***原子化操作***

​		一个好的框架应该只提供相关业务的**原子化操作**，由框架使用者根据业务自行组合原子化操作。ChessCanvas提供的原子化操作包	括：

1. 棋盘渲染（背景色模式或背景图模式）
2. 棋子渲染（canvas绘制或精灵图模式）
3. 棋子选中
4. 棋子取消选中
5. 棋子换选
6. 棋子移动
7. 吃子操作

- ***事件系统（生命周期）***

​		原生canvas是一个画布，不像传统DOM一样内置丰富的事件系统，但ChessCanvas针对中国象棋的可能场景提供了以下事件：

1. 点击棋子（选中棋子/吃子/换选棋子/取消选择）

2. 点击棋盘（选择棋子落点，当未选棋子时，对棋盘的点击属于无效点击，被忽略）

   除了以上事件，ChessCanvas还提供以下生命周期（生命周期的本质其实就是一系列必然按照既定顺序发生的事件）：

1. 棋盘渲染完毕
2. 棋子移动开始
3. 棋子移动结束

- ***解耦的动画实现***

​		动画的本质是在每一帧时清除画布，然后绘制下一帧的画面，当这个操作频繁且快速时，视觉暂留效应形成了我们大脑中的动画效果。一般来说，浏览器的帧率为60帧每秒，也就是平均16.66ms绘制一帧，只要我们每一帧时间内的js执行不超过这个间隔，浏览器就能按照这个理想帧率绘制动画。

​		canvas原生API并不自带动画功能，因此ChessCanvas采用前文所述的原理实现动画的封装，并允许开发者传入一个函数为参数，来定制动画的路线，但ChessCanvas本身实现了走直线的动画可供开发者直接调用。



# `ChessCanvas` API 参考 (`v1.0.0`)

> **概述：** `一款开箱即用的中国象棋canvas操作类库`
>
> **安装：**
> ```bash
> # 下载方式
> npm install chesscanvas
> ```

## 主要 API (按模块或功能域组织)

---

### 🧩 模块 A: `  Canvas层`

#### 🔹 `Class: Layer`
> **描述:** `所有canvas层的基类`
> **导入：**
>
> ```javascript
> import { Layer } from 'chesscanvas';
> // 作为基类，chesscanvas内部其他类继承此类，此类不应该被创建实例
> ```

*   **`constructor(options: ModuleAOptions)`**
    > **创建实例**
    ```typescript
    interface ModuleAOptions {
      prop1: string;  // 必填属性说明
      prop2?: number; // 可选属性说明 (默认值: 10)
      // ... 其他属性
    }
    ```
    **示例：**
    ```javascript
    const instance = new ModuleAClass({
      prop1: 'initialValue',
      prop2: 20
    });
    ```

*   **`instance.methodName(param1: Type, param2?: Type): ReturnType`**
    > **方法功能描述**
    > **参数:**
    > | 参数名                                                       | 类型    | 说明             | 默认值 | 必填 |
    > | ------------------------------------------------------------ | ------- | ---------------- | ------ | ---- |
    > | `param1`                                                     | `Type`  | `参数作用及约束` | -      | 是   |
    > | `param2`                                                     | `Type?` | `可选参数说明`   | `null` | 否   |
    > | **返回值：** `描述返回值类型和含义 (如: Promise<ResultType> | void)` |         |                  |        |      |
    > | **异常：** `可能抛出的错误类型和条件 (如: throws Error if param1 is empty)` |         |                  |        |      |
    > | **示例：**                                                   |         |                  |        |      |
    ```javascript
    const result = instance.methodName('requiredParam', { option: true });
    ```

*   **`static ModuleAClass.staticMethod(...): ...`**
    > **静态方法描述 (无需实例即可调用)**
    > （参数、返回值、示例同上）

*   **`property: Type` (实例属性)**
    > **属性作用描述 (可读/可写?)**
    > **类型：** `Type`
    > **约束：** `设置限制或注意事项 (如: 只读, 必须在初始化后设置)`
    > **示例：**
    ```javascript
    console.log(instance.property); // 读取
    // instance.property = newValue; // 是否可写？
    ```

---

### ⚙️ 模块 B: `工具函数 (Utility Functions)`

#### 🔹 `function utilityFunctionA(...): ...`
> **函数功能描述**
> **导入：**
```javascript
import { utilityFunctionA } from 'your-library/utils';
```


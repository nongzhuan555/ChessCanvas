<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>ChessCanvas的demo</h1>
    <div id="chess-canvas-container"></div>
</body>
<script type="module">
    import { Layer,BoardLayer,PieceLayer,Piece,EventLayer,animateFn,MoveMode } from '../index.js'
    console.log('ChessCanvas的demo启动...')
    const ChessBoard = new BoardLayer('chess-canvas-container',1)
    // const testSingle = new BoardLayer('chess-canvas-container',1)
    // console.log(ChessBoard===testSingle?'单例测试通过':'单例测试失败') // 单例测试
    // 以下为棋盘渲染示例
    // 设置背景图
    ChessBoard.setBackgroundImage('https://pic.52112.com/180309/180309_83/8fZmnuxTfu_small.jpg')
    // 依然需要设置背景色作为背景图加载失败的解决方案
    ChessBoard.draw(ChessBoard.getCanvasInstance(),ChessBoard.getCtx(),ChessBoard.backgroundColor)
    // 以下为棋子渲染示例
    const ChessPiece = new PieceLayer('chess-canvas-container',2)
    const redCar = new Piece(0,0,'car','red')
    const blackCar = new Piece(4,1,'car','black')
    ChessPiece.addPiece(redCar)
    ChessPiece.addPiece(blackCar)
    ChessPiece.draw()
    // 以下为创建事件层示例
    const ChessEvent = new EventLayer('chess-canvas-container',3)
    // 测试事件发布与订阅是否正常工作
    const eventBus = Layer.eventBus
    // 以下事件订阅位于初始同步任务（第一个宏任务）中，必然先于事件发布
    eventBus.on('BoardRendered',(arg)=>{
        // console.log('棋盘渲染成功',arg)
    })
    eventBus.on('BoardImgSucces',(arg)=>{
        // console.log(arg.msg)
    })
    eventBus.on('SelectPiece',(piece)=>{
        ChessPiece.selectPiece(piece)
        console.log('当前选中的棋子为:',PieceLayer.selectedPiece)
    })
    eventBus.on('WantMovePiece',(moveOption)=>{
        // 这里应该做移动校验，但示例中省略
        const option = moveOption.moveTo
        option.easing = MoveMode.easeInQuad
        option.duration = 500
        ChessPiece.animate(animateFn,option)
    })
    eventBus.on('AnimationStart',(animation)=>{
        // 开始移动后，将棋盘数组的原位置零
        ChessPiece.setPieceMap(null,animation.startX,animation.startY)
    })
    eventBus.on('AnimationEnd',(piece)=>{
        // 移动完成后，将棋盘数组的新位置赋值为棋子
        ChessPiece.setPieceMap(piece)
    })
</script>
<style>
    #chess-canvas-container{
        position: relative;
    }
</style>
</html>